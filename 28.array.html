<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        const myArray = ['第零個資料', '第一個資料', '第二個資料', '第三個資料', '第四個資料'];
        console.log('myArray',myArray);
        console.log('myArray[0]',myArray[0]);
        console.log('myArray[1]',myArray[1]);

        const districtArray = [
       ['七堵', '中正', '暖暖'],
       ['中正', '大安', '信義'],
       ['蘆洲', '三重', '新店'],
     ];
        console.log('districtArray',districtArray);
        console.log('districtArray[0][0]',districtArray[0][0]);
        console.log('districtArray[1][1]',districtArray[1][1]);
        console.log('districtArray[2][0]',districtArray[2][0]);

        districtArray.forEach(function(element){
            console.log('element',element);
            element.forEach(function(item){
                console.log('item',item);
            })
        })

        // 最基礎的迴圈
        for (var i = 0; i < 3; i++){
            // console.log('i:',districtArray[i]);
            for (var j = 0; j < 3; j++){
                // console.log('i:',districtArray[i][j]);
            }
        }

        // 如果我們知道要跑的陣列=全部資料有幾筆
        // 設定條件的地方可改成[陣列的長度](array.length)
        for (var i = 0; i < districtArray.length; i++){
            // console.log('i:',districtArray[i]);
            for (var j = 0; j < districtArray[i].length; j++){
                // console.log('i:',districtArray[i][j]);
            }
        }

        // 非同步
        // JS是單執行緒，如果中間被阻擋了，後面就不會執行
        // 在需要等待的時候，為了不阻礙執行流程，我們會把這件事丟給瀏覽器提供的API
        // 常見的是SetTimeout SetInterval Ajax
        // 這個秒數不是絕對，是最少要等幾秒後才會執行，可能會超過
        // 如果我的主線程執行的時間超過等待的秒數，那麼必須等我執行完，才可以執行setTimeout的東西
        // setTimeout(()=>{
        //     console.log('hi');
        // },3000);

        for (var i = 0; i < 3; i++){
            setTimeout(()=>{
            console.log('i',i);
        },3000);
        }
        // ES5必須使用閉包的概念來解決這個變數的問題
        // 閉包創建一個封閉的環境，裡面的變數會被鎖定在當時的數值
        // ES6的解決辦法，直接把宣告方法改成let來解決即可
        for (let i = 0; i < 3; i++){
            setTimeout(()=>{
            console.log('i',i);
        },3000);
        }
    </script>
</body>
</html>